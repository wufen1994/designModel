设计模式的目的：
    1.代码重用性：相同的代码不用多次编写
    2.可读性
    3.可扩展性
    4.可靠性
    5.高内聚低耦合的特性

设计模式的七大原则
    1.单一职责原则
    2.接口隔离原则
    3.依赖倒置原则
    4.里氏替换原则
    5.开闭原则
    6.迪米特法则
    7.合成复用原则：尽量使用合成/聚合，而不是继承

UML类图之间的关系：依赖，泛化，实现，关联，聚合，组合

设计模式分为三种类型，共23种：
    1.创建型模式：单例模式、工厂模式、抽象工厂模式、原型模式、建造者模式
    2.结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式
    3.行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、
        解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式（责任链模式）

1.单例模式有8种方式：
    1.饿汉式（静态常量）
        优点：写法简单，在类装载时完成实例化。避免线程同步问题。
        缺点：在类装载时就完成实例化，没有达到懒加载的效果，若从始至终未使用这个实例，会造成内存浪费。
        结论：这种单例模式可用，可能造成内存浪费。
    2.饿汉式（静态代码块）
        同1
    3.懒汉式（线程不安全）
    4.懒汉式（线程安全，同步方法）
        优点：解决线程不安全问题
        缺点：效率太低，每个线程在获得类实例时，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，
        后面的想获得该类实例，直接return就行。方法进行同步效率太低。
        结论：在实际开发中，不推荐使用
    5.懒汉式（线程安全，同步代码块）
        同4，且不能保证线程安全
        结论：实际开发中，不能使用这种方式
    6.双重检查
        Double-Check概念在多线程开发中经常使用的，进行两次的if判断，这样可以保证线程安全
        线程安全，延迟加载，效率较高
        结论：实际开发中，推荐使用这种单例设计模式
    7.静态内部类
        1.采用了类装载的机制来保证初始化实例时只有一个线程
        2.静态内部类方式在类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载内部类从而完成
            Singleton的实例化
        3.类的静态属性只会在第一次加载时初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法
            进入的
        4.优点：避免线程的不安全，利用静态内部类的特点实现延迟加载，效率高
        5.结论：推荐使用
    8.枚举
        不仅能避免多线程的同步问题，而且还能防止反序列化重新创建新的对象
        结论：推荐使用
    单例模式注意事项和细节说明
        1.单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以
            提高系统性能
        2.当想实例化一个单例类时，必须要记住使用相应的获取对象的方法，而不是使用new
        3.单例模式使用场景：需要频繁的进行创建和销毁的对象，创建对象时耗时过多或耗费资源过多（即重量级对象），但又经常
            用到的对象、工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等）
2.简单工厂模式
    优点：比较好理解，简单易操作
    缺点：违反涉及模式的OCP原则，即对扩展开放，对修改关闭。即当我们给类增加新功能时，尽量不修改代码，或者尽可能少修改代码

    基本介绍：
        简单工厂模式是属于创建型模式，是工厂模式的一种，简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂
        是工厂模式家族中最简单实用的模式。
        简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为
        在软件开发中，当我们会用到大量的创建某种，某类或某批对象时，就会使用到工厂模式

    工厂方法模式介绍：
        涉及方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现
        工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类，工厂方法模式将对象的实例化推迟到子类
    抽象工厂模式：
        定义：定义一个interface用于创建相关或有依赖关系的对象族，而无需指明具体的类
        抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合
        从设计层面看，抽象工厂模式就是对简单工厂模式的改进
        将工厂抽象成两层，AbstractFactory和具体实现工厂子类
    小结：
        工厂模式意义：
            将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦，从而提高项目的扩展
            和维护性
        三种工厂模式
        设计模式的依赖抽象原则
        1）创建对象实例时，不直接new类，而是把new类的动作放在一个工厂的方法中，并返回。即变量不用直接持有具体类的引用
        2）不要让类继承具体类，而是继承抽象类或实现接口
        3）不要覆盖基类中已实现的方法
3.原型模式
    基本介绍：
    1.原型模式(Prototype)：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象
    2.原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节
    3.工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来
        实施创建，即对象.clone()
    4.形象的理解：孙悟空的猴毛变成其它猴子

    深入讨论浅拷贝和深拷贝（1,2浅拷贝）（3.4深拷贝）
     1.数据类型时基本数据类型的成员变量，浅拷贝直接进行值传递，即将该属性的值复制一份给新的对象
     2.数据类型是引用类型的成员变量，如成员变量是数组、类的对象等，浅拷贝进行引用传递。
     3.复制对象的所有基本数据类型的成员变量值
     4.对象进行深拷贝要对整个对象进行拷贝。方式：重新clone方法来实现深拷贝；通过对象序列化实现深拷贝

    小结：
    创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时提高效率
    不用重新初始化对象，而是动态获取对象运行时的状态
    若原始对象发生变化，其克隆对象的也会发生变化，无需修改代码
    在实现深克隆时可能需要比较复杂的代码
    缺点：需为每个类配一个克隆方法，对原有的类改造时，会违法OCP原则

4.建造者模式
    基本介绍
    1.建造者模式是一种对象构建模式，它可以将复杂对象的建造过程抽象出来，使这个抽象过程的不同实现方法可以构造出不同表现的对象
    2.建造者模式是一步一步创建一个复杂的对象，塔允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需指定内部的具体
        构建细节
    四个角色：
    1.Product（产品角色）：一个具体的产品对象
    2.Builder(抽象建造者)：创建一个Product对象的各个部件指定的接口
    3.ConcreteBuilder(具体建造者)：实现接口，构建和装配各个部件
    4.Director(指挥者)：构建一个使用Builder接口的对象，它主要是用于创建一个复杂的对象。两个作用：隔离客户与对象的生产过程；
        负责控制产品对象的生产过程。
    注意事项和细节：
    1.不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦
    2.用户使用不同的具体建造者即可得到不同的产品对象
    3.可以更加精细地控制产品的创建过程
    4.增加新的具体建造者无须修改原有类库的代码，符合“开闭原则”
    5.建造者模式创建的产品一般需具有较多的共性，若差异较大，则不适合
    6.抽象工厂VS建造者模式：抽象工厂偏向于产品，建造者偏向于创建的流程

4.适配器模式
    基本介绍：
    1）适配器模式将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性
    2）适配器模式属于结构型模式
    3）主要分为三类：类适配器模式、对象适配器、接口适配器
    工作原理：
    1）将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容
    2）从用户的角度看不到适配者，是解耦的
    3）用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法
    4）用户收到反馈结果，感觉只是和目标接口交互
    对象适配器模式
    1）对象适配器和类适配器是同一种思想，只是实现方式不同
        使用组合替代类适配器的继承，解决了类适配器必须继承src的局限性问题，也不再要求dst是接口
    2）使用成本更低，更灵活
    接口适配器模式
    1）当不需要全部实现接口提供的方法时，先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空
        方法），该抽象类的子类可有选择的覆盖父类的方法
    2）适用于一个接口不想使用其所有的方法
    源码：handlerAdapter，不同的handler会适配不同的适配器

5.桥接模式
    意图：将抽象部分与实现部分分离，使它们都可以独立的变化。
    主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。
    何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。
    基本介绍：
    1）桥接模式指将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变
    2）是一种结构型设计模式
    3）桥接模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责，主要特点是把抽象
        与行为实现分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展
    优点： 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。
    缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计
        与编程。

6.装饰者模式
    定义：动态的将新功能附加到对象上，在对象功能方面，比继承有弹性，也体现了开闭原则（OCP）
    主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。
    何时使用：在不想增加很多子类的情况下扩展类。
    优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。
    缺点：多层装饰比较复杂。
    使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。
    源码：JDK的IO体系中

7.组合模式
    基本介绍：
    1）又叫部分整体模式，创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系
    2）组合模式依据树形结构来组合对象，用来表示部分以及整体层次
    3）这种类型的设计模式属于结构型模式
    4）组合能让客户已一致的方式处理个别对象以及组合对象
